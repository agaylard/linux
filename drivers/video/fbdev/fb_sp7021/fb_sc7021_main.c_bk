/**************************************************************************
 *                                                                        *
 *         Copyright (c) 2018 by Sunplus Inc.                             *
 *                                                                        *
 *  This software is copyrighted by and is the property of Sunplus        *
 *  Inc. All rights are reserved by Sunplus Inc.                          *
 *  This software may only be used in accordance with the                 *
 *  corresponding license agreement. Any unauthorized use, duplication,   *
 *  distribution, or disclosure of this software is expressly forbidden.  *
 *                                                                        *
 *  This Copyright notice MUST not be removed or modified without prior   *
 *  written consent of Sunplus Technology Co., Ltd.                       *
 *                                                                        *
 *  Sunplus Inc. reserves the right to modify this software               *
 *  without notice.                                                       *
 *                                                                        *
 *  Sunplus Inc.                                                          *
 *  19, Innovation First Road, Hsinchu Science Park                       *
 *  Hsinchu City 30078, Taiwan, R.O.C.                                    *
 *                                                                        *
 **************************************************************************/

/**
 * @file fb_sc7021_main.c
 * @brief linux kernel framebuffer main driver
 * @author PoChou Chen
 */
/**************************************************************************
 *                         H E A D E R   F I L E S
 **************************************************************************/
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fb.h>
#include "fb_sc7021_main.h"

/**************************************************************************
 *                           C O N S T A N T S                            *
 **************************************************************************/
/* create FB device number(MAX==3) */
#define FB_DEV_NUM			3
#if (FB_DEV_NUM > 3)
	#error "FB device can't large than 3"
#endif

#define FB_PALETTE_LEN		(1024)

#define CMD_LEN				(256)

#define IPC_FunctionCall(...)	0

/**************************************************************************
 *                              M A C R O S                               *
 **************************************************************************/
#define DISP_ALIGN(x, n)		(((x) + ((n) - 1)) & ~((n) - 1))

/* #define DEBUG_MSG */
#ifdef DEBUG_MSG
	#define mod_dbg(fmt, arg...)	pr_debug("[%s:%d] "fmt, \
			__func__, \
			__LINE__, \
			##arg)
#else
	#define mod_dbg(...)
#endif

#define mod_err(fmt, arg...)		pr_err("[%s:%d] Error! "fmt, \
		__func__, \
		__LINE__, \
		##arg)
#define mod_warn(fmt, arg...)	pr_warn("[%s:%d] Warning! "fmt, \
		__func__, \
		__LINE__, \
		##arg)
#define mod_info(fmt, arg...)		pr_info("[%s:%d] "fmt, \
		__func__, \
		__LINE__, \
		##arg)

/**************************************************************************
 *                          D A T A    T Y P E S                          *
 **************************************************************************/
typedef struct _framebuffer_t {
	struct fb_info			*fb;

	int						win_id;
	int						win_handle;
	int						fbwidth;
	int						fbheight;

	DRV_OsdRegionFormat_e	ColorFmt;
	char					ColorFmtName[24];
	int						fbpagesize;
	int						fbpagenum;
	int						fbsize;
	void __iomem			*fbmem;
	void __iomem			*fbmem_palette;
} framebuffer_t;

/**************************************************************************
 *               F U N C T I O N    D E C L A R A T I O N S               *
 **************************************************************************/
static int fbdss_open(struct fb_info *fbinfo, int user);
static int fbdss_release(struct fb_info *fbinfo, int user);
static int fbdss_set_par(struct fb_info *fbinfo);
static int fbdss_pan_display(struct fb_var_screeninfo *var,
		struct fb_info *fbinfo);
static int fbdss_waitVsync(struct fb_info *info);
static int fbdss_setcmap(struct fb_cmap *cmap, struct fb_info *info);

static int _ipc_swapbuf(FB_IPC_Info_t *info, int buf_max);

/**************************************************************************
 *                         G L O B A L    D A T A                         *
 **************************************************************************/
static struct fb_info *gFB_INFO[FB_DEV_NUM] = {NULL};

static struct fb_ops framebuffer_ops = {
	.owner				= THIS_MODULE,
	.fb_open			= fbdss_open,
	.fb_release			= fbdss_release,
	.fb_set_par			= fbdss_set_par,
	.fb_pan_display		= fbdss_pan_display,
	.fb_sync			= fbdss_waitVsync,
	.fb_setcmap			= fbdss_setcmap,
};

static const struct of_device_id _sc7021_fb_dt_ids[] = {
	{ .compatible = "sunplus,sc7021-fb", },
	{ /* Sentinel */ }
};
MODULE_DEVICE_TABLE(of, _sc7021_fb_dt_ids);

static struct platform_driver _sc7021_fb_driver = {
	.probe		= _sc7021_fb_probe,
	.remove		= _sc7021_fb_remove,
	.driver		= {
		.name	= "sc7021-fb",
		.owner	= THIS_MODULE,
		.of_match_table = of_match_ptr(_sc7021_fb_dt_ids),
#if 0
#ifdef CONFIG_PM
		.pm		= &_sc7021_pwm_pm_ops,
#endif
#endif
	},
};
module_platform_driver(_sc7021_fb_driver);

/**************************************************************************
 *             F U N C T I O N    I M P L E M E N T A T I O N S           *
 **************************************************************************/
static inline unsigned int _chan_by_field(unsigned char chan,
		struct fb_bitfield *bf)
{
	unsigned int ret_chan = (unsigned int)chan;

	ret_chan >>= 8 - bf->length;

	return ret_chan << bf->offset;
}

static int _ipc_swapbuf(FB_IPC_Info_t *info, int buf_max)
{
	int retIPC = 0;

	if (!info) {
		mod_err("IPC info is NULL\n");
		return -1;
	}

	if (info->buf_id >= buf_max) {
		mod_err("buffer ID >= max buffer num(%d >= %d)\n",
				info->buf_id,
				buf_max);
		return -1;
	}

	mod_dbg("Swap buffer ID = %d, win_id = %d\n",
			info->buf_id,
			info->win_id);

	retIPC = IPC_FunctionCall(IPC_CMD_DISP_SWAP_BUFF,
			info,
			sizeof(FB_IPC_Info_t));
	if (retIPC)
		mod_err("IPC fail(IPC_CMD_DISP_SWAP_BUFF) = %d\n", retIPC);

	return retIPC;
}

static int _create_device(int device_id, UI_FB_Info *Info)
{
	struct fb_info *fbinfo = NULL;
	framebuffer_t *fbWorkMem = NULL;

	if (!Info) {
		mod_err("FB info is NULL\n");
		goto ERROR_HANDLE_FB_INIT;
	}

	if (!(Info->UI_winid >= 0 && Info->UI_winid < DRV_OSD_MAX)) {
		mod_err("win_id:%d, must smaller then %d\n",
				Info->UI_winid,
				DRV_OSD_MAX);
		goto ERROR_HANDLE_FB_INIT;
	}

	fbinfo = framebuffer_alloc(sizeof(framebuffer_t), NULL);

	if (fbinfo == NULL) {
		mod_err("win_id:%d, framebuffer_alloc failed\n",
				Info->UI_winid);
		goto ERROR_HANDLE_FB_INIT;
	}

	fbWorkMem = fbinfo->par;
	memset(fbWorkMem, 0, sizeof(framebuffer_t));
	fbWorkMem->fb = fbinfo;

	/* Initial our framebuffer context */
	fbWorkMem->win_id = Info->UI_winid;
	fbWorkMem->ColorFmt = Info->UI_ColorFmt;
	snprintf(fbWorkMem->ColorFmtName,
			sizeof(fbWorkMem->ColorFmtName) - 1,
			"%s",
			Info->UI_Colormode.name);
	fbWorkMem->fbwidth = Info->UI_width;
	fbWorkMem->fbheight = Info->UI_height;

	if (Info->UI_bufAlign % PAGE_SIZE) {
		mod_err("UI buf align: %d, Linux page align: %d\n",
				Info->UI_bufAlign,
				(int)PAGE_SIZE);
		goto ERROR_HANDLE_FB_INIT;
	}

	fbWorkMem->fbpagesize = DISP_ALIGN((fbWorkMem->fbwidth
			* fbWorkMem->fbheight
			* (Info->UI_Colormode.bits_per_pixel >> 3)),
			Info->UI_bufAlign);
	fbWorkMem->fbpagenum = Info->UI_bufNum;
	fbWorkMem->fbsize = fbWorkMem->fbpagesize * fbWorkMem->fbpagenum;

	/* Allocate Buffer */
	fbWorkMem->fbmem = chunk_malloc(DRAM_B, fbWorkMem->fbsize);

	if (fbWorkMem->fbmem == NULL) {
		mod_err("win_id:%d, malloc failed, size %d(%dx%dx(%d/8)*%d)\n",
			fbWorkMem->win_id,
			fbWorkMem->fbsize,
			fbWorkMem->fbwidth,
			fbWorkMem->fbheight,
			Info->UI_Colormode.bits_per_pixel,
			fbWorkMem->fbpagenum);
		goto ERROR_HANDLE_FB_INIT;
	}
	memset(fbWorkMem->fbmem, 0, fbWorkMem->fbsize);

	if (fbWorkMem->ColorFmt == DRV_OSD_REGION_FORMAT_8BPP) {
		fbWorkMem->fbmem_palette = chunk_malloc(DRAM_B, FB_PALETTE_LEN);

		if (fbWorkMem->fbmem_palette == NULL) {
			mod_err("win_id:%d, malloc failed, size %d\n",
					fbWorkMem->win_id, FB_PALETTE_LEN);
			goto ERROR_HANDLE_FB_INIT;
		}
		memset(fbWorkMem->fbmem_palette, 0, FB_PALETTE_LEN);
	}

	fbinfo->fbops = &framebuffer_ops;
	fbinfo->flags = FBINFO_FLAG_DEFAULT;

	if (fbWorkMem->ColorFmt == DRV_OSD_REGION_FORMAT_8BPP)
		fbinfo->pseudo_palette = fbWorkMem->fbmem_palette;
	else
		fbinfo->pseudo_palette = NULL;
	fbinfo->screen_base = fbWorkMem->fbmem;
	fbinfo->screen_size = fbWorkMem->fbsize;

	/* Resolution */
	fbinfo->var.xres = fbWorkMem->fbwidth;
	fbinfo->var.yres = fbWorkMem->fbheight;
	fbinfo->var.xres_virtual = fbWorkMem->fbwidth;
	fbinfo->var.yres_virtual = fbWorkMem->fbheight * fbWorkMem->fbpagenum;

	/* Timing */
	/* fake setting fps 59.94 */
	fbinfo->var.left_margin		= 60;		/* HBProch */
	fbinfo->var.right_margin	= 16;		/* HFPorch */
	fbinfo->var.upper_margin	= 30;		/* VBPorch */
	fbinfo->var.lower_margin	= 10;		/* VFPorch */
	/* HSWidth */
	fbinfo->var.hsync_len		= 10 - ((fbWorkMem->fbwidth
				+ fbinfo->var.left_margin
				+ fbinfo->var.right_margin) % 10);
	/* VSWidth */
	fbinfo->var.vsync_len		= 10 - ((fbWorkMem->fbheight
				+ fbinfo->var.upper_margin
				+ fbinfo->var.lower_margin) % 10);
	/* 1000000000000/pixel clk */
	fbinfo->var.pixclock		= 1000000000
		/ ((fbWorkMem->fbwidth
					+ fbinfo->var.left_margin
					+ fbinfo->var.right_margin
					+ fbinfo->var.hsync_len) / 10)
		/ ((fbWorkMem->fbheight
					+ fbinfo->var.upper_margin
					+ fbinfo->var.lower_margin
					+ fbinfo->var.vsync_len) / 10)
		/ 6;
	fbinfo->var.pixclock += (fbinfo->var.pixclock / 1000)
		+ ((fbinfo->var.pixclock % 1000) ? 1 : 0);

	fbinfo->var.activate		= FB_ACTIVATE_NXTOPEN;
	fbinfo->var.accel_flags		= 0;
	fbinfo->var.vmode			= FB_VMODE_NONINTERLACED;

	/* color format */
	fbinfo->var.bits_per_pixel	= Info->UI_Colormode.bits_per_pixel;
	fbinfo->var.nonstd			= Info->UI_Colormode.nonstd;
	fbinfo->var.red				= Info->UI_Colormode.red;
	fbinfo->var.green			= Info->UI_Colormode.green;
	fbinfo->var.blue			= Info->UI_Colormode.blue;
	fbinfo->var.transp			= Info->UI_Colormode.transp;

	/* fixed info */
	snprintf(fbinfo->fix.id,
			sizeof(fbinfo->fix.id) - 1,
			"FB-O%d-%dx%d",
			fbWorkMem->win_id,
			fbWorkMem->fbwidth,
			fbWorkMem->fbheight);
	fbinfo->fix.mmio_start	= 0;
	fbinfo->fix.mmio_len	= 0;
	fbinfo->fix.type		= FB_TYPE_PACKED_PIXELS;
	fbinfo->fix.type_aux	= 0;

	if (fbWorkMem->ColorFmt == DRV_OSD_REGION_FORMAT_8BPP)
		fbinfo->fix.visual = FB_VISUAL_PSEUDOCOLOR;
	else
		fbinfo->fix.visual = FB_VISUAL_TRUECOLOR;
	fbinfo->fix.xpanstep	= 0;
	fbinfo->fix.ypanstep	= 1;
	fbinfo->fix.ywrapstep	= 0;
	fbinfo->fix.accel		= FB_ACCEL_NONE;
	fbinfo->fix.smem_start	= chunk_pa(fbWorkMem->fbmem);
	fbinfo->fix.smem_len	= fbWorkMem->fbsize;
	fbinfo->fix.line_length	= fbinfo->var.xres_virtual
		* (Info->UI_Colormode.bits_per_pixel >> 3);

	if (register_framebuffer(fbinfo) != 0) {
		mod_err("win_id:%d, register framebuffer failed\n",
				fbWorkMem->win_id);
		goto ERROR_HANDLE_FB_INIT;
	}

	Info->UI_bufAddr = (UINT32)fbinfo->fix.smem_start;
	Info->UI_bufAddr_pal = chunk_pa(fbWorkMem->fbmem_palette);
	Info->UI_bufsize = fbWorkMem->fbsize;

	mod_info("fb%d, win_id %d, mem VA 0x%x(PA 0x%x), Palette VA 0x%x(PA 0x%x), UI Res %dx%d, size %d + %d\n",
			device_id,
			fbWorkMem->win_id,
			(UINT32)fbWorkMem->fbmem,
			Info->UI_bufAddr,
			(UINT32)fbWorkMem->fbmem_palette,
			Info->UI_bufAddr_pal,
			fbWorkMem->fbwidth,
			fbWorkMem->fbheight,
			fbWorkMem->fbsize,
			(fbWorkMem->ColorFmt == DRV_OSD_REGION_FORMAT_8BPP)
			? FB_PALETTE_LEN : 0);

	gFB_INFO[device_id] = fbinfo;

	return 0;

ERROR_HANDLE_FB_INIT:
	if (Info)
		mod_err("win_id:%d, Have error\n", Info->UI_winid);

	if (fbWorkMem) {
		if (fbWorkMem->fbmem)
			chunk_free(fbWorkMem->fbmem);
		if (fbWorkMem->fbmem_palette)
			chunk_free(fbWorkMem->fbmem_palette);
	}
	if (fbinfo)
		framebuffer_release(fbinfo);
	return -1;
}

static void _WakeUpEcosDisplay(UI_FB_Info *pInfo)
{
	int retIPC = 0;

	retIPC = IPC_FunctionCall(IPC_CMD_DISP_INIT,
			pInfo,
			sizeof(UI_FB_Info) * UI_FB_INFO_NUM);
	if (retIPC)
		mod_err("IPC fail(IPC_CMD_DISP_INIT) = %d\n", retIPC);
}

#if 0
static int _Get_UI_Res(UI_FB_Info *pInfo)
{
	int retIPC = 0;

	retIPC = IPC_FunctionCall(IPC_CMD_DISP_GET_FB_INFO,
			pInfo,
			sizeof(UI_FB_Info) * UI_FB_INFO_NUM);

	if (retIPC)
		mod_err("IPC fail(IPC_CMD_DISP_GET_FB_mod_info) = %d\n",
				retIPC);

	return retIPC;
}

static void _Set_UI_handle(UI_FB_Info *pInfo)
{
	framebuffer_t *fb_par = NULL;
	int i, j;

	for (i = 0; i < FB_DEV_NUM; ++i) {
		for (j = 0; j < UI_FB_INFO_NUM; ++j) {
			if (!gFB_INFO[i])
				break;
			fb_par = gFB_INFO[i]->par;
			if (fb_par->win_id == pInfo[j].UI_winid)
				fb_par->win_handle = pInfo[j].UI_OsdHandle;
		}
	}
}
#endif

static int fbdss_open(struct fb_info *fbinfo, int user)
{
	/* Do nothing */
	return 0;
}

static int fbdss_release(struct fb_info *fbinfo, int user)
{
	/* Not supported release */
	return 0;
}

static int fbdss_set_par(struct fb_info *fbinfo)
{
	return 0;
}

static int fbdss_pan_display(struct fb_var_screeninfo *var,
		struct fb_info *fbinfo)
{
	framebuffer_t *fb_par = (framebuffer_t *)fbinfo->par;
	FB_IPC_Info_t ipc_data = {.win_id = -1};
	int retIPC = 0;

	fbinfo->var.xoffset = var->xoffset;
	fbinfo->var.yoffset = var->yoffset;

	ipc_data.buf_id = fbinfo->var.yoffset / fbinfo->var.yres;
	ipc_data.win_id = fb_par->win_id;

	retIPC = _ipc_swapbuf(&ipc_data, fb_par->fbpagenum);

	if (!retIPC) {
		if (!fb_par->win_handle) {
//			UI_FB_Info Info[UI_FB_INFO_NUM] = { {0} };

//			retIPC = _Get_UI_Res(Info);
			if (retIPC) {
				mod_err("Get UI info fails");
				retIPC = 0;
			} else {
//				_Set_UI_handle(Info);
			}
		}
	}

	return retIPC;
}

static int fbdss_waitVsync(struct fb_info *info)
{
	FB_IPC_Info_t ipc_data = {.win_id = -1};
	int retIPC;

	ipc_data.win_id = ((framebuffer_t *)(info->par))->win_id;
	mod_dbg("Wait Vsync: %d\n", ipc_data.win_id);

	retIPC = IPC_FunctionCall(IPC_CMD_DISP_WAIT_VSYNC,
			&ipc_data,
			sizeof(FB_IPC_Info_t));
	if (retIPC)
		mod_err("IPC fail(IPC_CMD_DISP_WAIT_VSYNC) = %d\n", retIPC);

	return 0;
}

static int fbdss_setcmap(struct fb_cmap *cmap, struct fb_info *info)
{
	framebuffer_t *fb_par = (framebuffer_t *)info->par;
	int i;
	unsigned short *red, *green, *blue, *transp;
	unsigned short trans = 0xffff;
	unsigned int *palette = (unsigned int *)info->pseudo_palette;

	if ((fb_par->ColorFmt != DRV_OSD_REGION_FORMAT_8BPP) || (!palette))
		return -1;

	red = cmap->red;
	green = cmap->green;
	blue = cmap->blue;
	transp = cmap->transp;

	for (i = cmap->start;
			(i < (cmap->start + cmap->len)) ||
				(i < (FB_PALETTE_LEN / sizeof(unsigned int)));
			++i) {
		if (transp)
			trans = *(transp++);

		palette[i] = _chan_by_field((unsigned char)trans,
				&info->var.transp);
		palette[i] |= _chan_by_field((unsigned char)*(red++),
				&info->var.red);
		palette[i] |= _chan_by_field((unsigned char)*(green++),
				&info->var.green);
		palette[i] |= _chan_by_field((unsigned char)*(blue++),
				&info->var.blue);
	}
	return 0;
}

static void _sc7021_fb_remove(void)
{
	int i;

	for (i = 0; i < FB_DEV_NUM; ++i) {
		if (gFB_INFO[i]) {
			if (unregister_framebuffer(gFB_INFO[i]))
				mod_err("unregister framebuffer error\n");
			chunk_free(gFB_INFO[i]->screen_base);
			framebuffer_release(gFB_INFO[i]);
			gFB_INFO[i] = NULL;
		}
	}
}

static int _sc7021_fb_probe(void)
{
//	int ret = 0;
	int device_id = 0;
	UI_FB_Info Info = {0, 800, 480, 2, 4096, 0, 0xe, {.bits_per_pixel = 0,}, 0, 0, 0, 0};

#if 0
	ret = _Get_UI_Res(Info);

	if (ret) {
		mod_err("Get UI resolution fails");
		goto ERROR_HANDLE_FB_INIT;
	}
#endif
	mod_err("mac test");

	mod_dbg("try Create device %d: win_id = %d, %dx%d\n",
			device_id, Info.UI_winid,
			Info.UI_width,
			Info.UI_height);
	if (!(Info.UI_width == 0 || Info.UI_height == 0)) {
		if (_create_device(device_id, &Info))
			goto ERROR_HANDLE_FB_INIT;
		++device_id;
	} else {
		Info.UI_winid = -1;
	}

	_WakeUpEcosDisplay(&Info);

	return 0;

ERROR_HANDLE_FB_INIT:
	_sc7021_fb_remove();
	return -1;
}

#if 0
/* coverity issue */
#ifdef MODULE
//static inline initcall_t __inittest(void) __attribute__((used));
//static inline exitcall_t __exittest(void) __attribute__((used));
#endif
module_init(fbdss_init);
module_exit(fbdss_exit);
#endif

MODULE_DESCRIPTION("SC7021 Framebuffer Driver");
MODULE_AUTHOR("PoChou Chen <pochou.chen@sunplus.com>");
MODULE_LICENSE("GPL");

